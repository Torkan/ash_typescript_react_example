// Generated by AshTypescript
// Do not edit this file manually

import { z } from "zod";


type AshDate = string;
type Decimal = string;
type UUID = string;

// AshTypescriptReactExampleAccountsUser Schema
export type AshTypescriptReactExampleAccountsUserResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email";
  id: UUID;
  email: string;
};



// Company Schema
export type CompanyResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "name" | "addressLine1" | "addressLine2" | "city" | "postalCode" | "country" | "vatNumber" | "email" | "phone" | "isDefault";
  id: UUID;
  userId: UUID;
  name: string;
  addressLine1: string;
  addressLine2: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber: string | null;
  email: string | null;
  phone: string | null;
  isDefault: boolean;
  user: { __type: "Relationship"; __resource: AshTypescriptReactExampleAccountsUserResourceSchema; };
};



// Customer Schema
export type CustomerResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "name" | "addressLine1" | "addressLine2" | "city" | "postalCode" | "country" | "vatNumber" | "email" | "phone" | "isActive";
  id: UUID;
  userId: UUID;
  name: string;
  addressLine1: string;
  addressLine2: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber: string | null;
  email: string | null;
  phone: string | null;
  isActive: boolean;
};



// Invoice Schema
export type InvoiceResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "serialNumber" | "state" | "issueDate" | "dueDate" | "companyName" | "companyAddressLine1" | "companyAddressLine2" | "companyCity" | "companyPostalCode" | "companyCountry" | "companyVatNumber" | "companyEmail" | "companyPhone" | "customerName" | "customerAddressLine1" | "customerAddressLine2" | "customerCity" | "customerPostalCode" | "customerCountry" | "customerVatNumber" | "customerEmail" | "customerPhone" | "currency";
  id: UUID;
  userId: UUID;
  serialNumber: string | null;
  state: "draft" | "finalized" | "cancelled";
  issueDate: AshDate;
  dueDate: AshDate;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber: string | null;
  companyEmail: string | null;
  companyPhone: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber: string | null;
  customerEmail: string | null;
  customerPhone: string | null;
  currency: string;
};



// InvoiceLine Schema
export type InvoiceLineResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "invoiceId" | "lineNumber" | "description" | "quantity" | "unitPrice" | "taxRate";
  id: UUID;
  invoiceId: UUID;
  lineNumber: number;
  description: string;
  quantity: Decimal;
  unitPrice: Decimal;
  taxRate: Decimal;
};



// CreditNote Schema
export type CreditNoteResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "serialNumber" | "state" | "issueDate" | "originalInvoiceId" | "creditReason" | "companyName" | "companyAddressLine1" | "companyAddressLine2" | "companyCity" | "companyPostalCode" | "companyCountry" | "companyVatNumber" | "companyEmail" | "companyPhone" | "customerName" | "customerAddressLine1" | "customerAddressLine2" | "customerCity" | "customerPostalCode" | "customerCountry" | "customerVatNumber" | "customerEmail" | "customerPhone" | "currency";
  id: UUID;
  userId: UUID;
  serialNumber: string | null;
  state: "draft" | "finalized" | "cancelled";
  issueDate: AshDate;
  originalInvoiceId: UUID | null;
  creditReason: string;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber: string | null;
  companyEmail: string | null;
  companyPhone: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber: string | null;
  customerEmail: string | null;
  customerPhone: string | null;
  currency: string;
};



// CreditNoteLine Schema
export type CreditNoteLineResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "creditNoteId" | "lineNumber" | "description" | "quantity" | "unitPrice" | "taxRate";
  id: UUID;
  creditNoteId: UUID;
  lineNumber: number;
  description: string;
  quantity: Decimal;
  unitPrice: Decimal;
  taxRate: Decimal;
};



// SequenceNumber Schema
export type SequenceNumberResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "documentType" | "nextNumber";
  id: UUID;
  userId: UUID;
  documentType: "invoice" | "credit_note";
  nextNumber: number;
};





export type AshTypescriptReactExampleAccountsUserFilterInput = {
  and?: Array<AshTypescriptReactExampleAccountsUserFilterInput>;
  or?: Array<AshTypescriptReactExampleAccountsUserFilterInput>;
  not?: Array<AshTypescriptReactExampleAccountsUserFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type CompanyFilterInput = {
  and?: Array<CompanyFilterInput>;
  or?: Array<CompanyFilterInput>;
  not?: Array<CompanyFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  addressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  addressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  city?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  postalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  country?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  vatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  phone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isDefault?: {
    eq?: boolean;
    notEq?: boolean;
  };


  user?: AshTypescriptReactExampleAccountsUserFilterInput;

};
export type CustomerFilterInput = {
  and?: Array<CustomerFilterInput>;
  or?: Array<CustomerFilterInput>;
  not?: Array<CustomerFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  addressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  addressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  city?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  postalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  country?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  vatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  phone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isActive?: {
    eq?: boolean;
    notEq?: boolean;
  };



};
export type InvoiceFilterInput = {
  and?: Array<InvoiceFilterInput>;
  or?: Array<InvoiceFilterInput>;
  not?: Array<InvoiceFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  serialNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  state?: {
    eq?: "draft" | "finalized" | "cancelled";
    notEq?: "draft" | "finalized" | "cancelled";
    in?: Array<"draft" | "finalized" | "cancelled">;
  };

  issueDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  dueDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  companyName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyAddressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyAddressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyCity?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyPostalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyCountry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyVatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyEmail?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyPhone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerAddressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerAddressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerCity?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerPostalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerCountry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerVatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerEmail?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerPhone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  currency?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type InvoiceLineFilterInput = {
  and?: Array<InvoiceLineFilterInput>;
  or?: Array<InvoiceLineFilterInput>;
  not?: Array<InvoiceLineFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  invoiceId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  lineNumber?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  quantity?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  unitPrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  taxRate?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };



};
export type CreditNoteFilterInput = {
  and?: Array<CreditNoteFilterInput>;
  or?: Array<CreditNoteFilterInput>;
  not?: Array<CreditNoteFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  serialNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  state?: {
    eq?: "draft" | "finalized" | "cancelled";
    notEq?: "draft" | "finalized" | "cancelled";
    in?: Array<"draft" | "finalized" | "cancelled">;
  };

  issueDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  originalInvoiceId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  creditReason?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyAddressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyAddressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyCity?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyPostalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyCountry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyVatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyEmail?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyPhone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerAddressLine1?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerAddressLine2?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerCity?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerPostalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerCountry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerVatNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerEmail?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  customerPhone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  currency?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type CreditNoteLineFilterInput = {
  and?: Array<CreditNoteLineFilterInput>;
  or?: Array<CreditNoteLineFilterInput>;
  not?: Array<CreditNoteLineFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  creditNoteId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  lineNumber?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  quantity?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  unitPrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  taxRate?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };



};
export type SequenceNumberFilterInput = {
  and?: Array<SequenceNumberFilterInput>;
  or?: Array<SequenceNumberFilterInput>;
  not?: Array<SequenceNumberFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  documentType?: {
    eq?: "invoice" | "credit_note";
    notEq?: "invoice" | "credit_note";
    in?: Array<"invoice" | "credit_note">;
  };

  nextNumber?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };



};


// Utility Types

// Resource schema constraint
type TypedSchema = {
  __type: "Resource" | "TypedStruct" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : NonNullable<T[K]> extends TypedSchema
        ? UnifiedFieldSelection<NonNullable<T[K]>>[]
        : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends TypedSchema
              ? null extends T[K]
                ? InferResult<NonNullable<T[K]>, Field[K]> | null
                : InferResult<NonNullable<T[K]>, Field[K]>
              : never
          : never;
      }
    : never;

type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[],
> = UnionToIntersection<
  {
    [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
  }[number]
>;


// Helper Functions

/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(): Record<string, string> {
  const headers: Record<string, string> = {};

  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}



// ============================
// Typed Queries
// ============================
// Use these types and field constants for server-side rendering and data fetching.
// The field constants can be used with the corresponding RPC actions for client-side refetching.

// CreditNote Typed Queries
// Type for credit_notes_list_view
export type CreditNotesListView = Array<InferResult<CreditNoteResourceSchema, ["id", "serialNumber", "state", "issueDate", "companyName", "customerName", "currency", "creditReason"]>>;

// Field selection for credit_notes_list_view - use with RPC actions for refetching
export const creditNotesListFields = ["id" as const, "serialNumber" as const, "state" as const, "issueDate" as const, "companyName" as const, "customerName" as const, "currency" as const, "creditReason" as const];


// Type for credit_note_edit_view
export type CreditNoteEditView = InferResult<CreditNoteResourceSchema, ["id", "serialNumber", "state", "issueDate", "companyName", "companyAddressLine1", "companyAddressLine2", "companyCity", "companyPostalCode", "companyCountry", "companyVatNumber", "companyEmail", "companyPhone", "customerName", "customerAddressLine1", "customerAddressLine2", "customerCity", "customerPostalCode", "customerCountry", "customerVatNumber", "customerEmail", "customerPhone", "currency"]>;

// Field selection for credit_note_edit_view - use with RPC actions for refetching
export const creditNoteEditFields = ["id" as const, "serialNumber" as const, "state" as const, "issueDate" as const, "companyName" as const, "companyAddressLine1" as const, "companyAddressLine2" as const, "companyCity" as const, "companyPostalCode" as const, "companyCountry" as const, "companyVatNumber" as const, "companyEmail" as const, "companyPhone" as const, "customerName" as const, "customerAddressLine1" as const, "customerAddressLine2" as const, "customerCity" as const, "customerPostalCode" as const, "customerCountry" as const, "customerVatNumber" as const, "customerEmail" as const, "customerPhone" as const, "currency" as const];



// Company Typed Queries
// Type for companies_list_view
export type CompaniesListView = Array<InferResult<CompanyResourceSchema, ["id", "name", "addressLine1", "addressLine2", "city", "postalCode", "country", "vatNumber", "email", "phone", "isDefault"]>>;

// Field selection for companies_list_view - use with RPC actions for refetching
export const companiesListFields = ["id" as const, "name" as const, "addressLine1" as const, "addressLine2" as const, "city" as const, "postalCode" as const, "country" as const, "vatNumber" as const, "email" as const, "phone" as const, "isDefault" as const];


// Type for company_edit_view
export type CompanyEditView = InferResult<CompanyResourceSchema, ["id", "name", "addressLine1", "addressLine2", "city", "postalCode", "country", "vatNumber", "email", "phone", "isDefault"]>;

// Field selection for company_edit_view - use with RPC actions for refetching
export const companyEditFields = ["id" as const, "name" as const, "addressLine1" as const, "addressLine2" as const, "city" as const, "postalCode" as const, "country" as const, "vatNumber" as const, "email" as const, "phone" as const, "isDefault" as const];



// Invoice Typed Queries
// Type for invoices_list_view
export type InvoicesListView = Array<InferResult<InvoiceResourceSchema, ["id", "serialNumber", "state", "issueDate", "dueDate", "companyName", "customerName", "currency"]>>;

// Field selection for invoices_list_view - use with RPC actions for refetching
export const invoicesListFields = ["id" as const, "serialNumber" as const, "state" as const, "issueDate" as const, "dueDate" as const, "companyName" as const, "customerName" as const, "currency" as const];


// Type for invoice_edit_view
export type InvoiceEditView = InferResult<InvoiceResourceSchema, ["id", "serialNumber", "state", "issueDate", "dueDate", "companyName", "companyAddressLine1", "companyAddressLine2", "companyCity", "companyPostalCode", "companyCountry", "companyVatNumber", "companyEmail", "companyPhone", "customerName", "customerAddressLine1", "customerAddressLine2", "customerCity", "customerPostalCode", "customerCountry", "customerVatNumber", "customerEmail", "customerPhone", "currency"]>;

// Field selection for invoice_edit_view - use with RPC actions for refetching
export const invoiceEditFields = ["id" as const, "serialNumber" as const, "state" as const, "issueDate" as const, "dueDate" as const, "companyName" as const, "companyAddressLine1" as const, "companyAddressLine2" as const, "companyCity" as const, "companyPostalCode" as const, "companyCountry" as const, "companyVatNumber" as const, "companyEmail" as const, "companyPhone" as const, "customerName" as const, "customerAddressLine1" as const, "customerAddressLine2" as const, "customerCity" as const, "customerPostalCode" as const, "customerCountry" as const, "customerVatNumber" as const, "customerEmail" as const, "customerPhone" as const, "currency" as const];



// Customer Typed Queries
// Type for customers_list_view
export type CustomersListView = Array<InferResult<CustomerResourceSchema, ["id", "name", "addressLine1", "addressLine2", "city", "postalCode", "country", "vatNumber", "email", "phone", "isActive"]>>;

// Field selection for customers_list_view - use with RPC actions for refetching
export const customersListFields = ["id" as const, "name" as const, "addressLine1" as const, "addressLine2" as const, "city" as const, "postalCode" as const, "country" as const, "vatNumber" as const, "email" as const, "phone" as const, "isActive" as const];




export type CreateCompanyInput = {
  name: string;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber?: string | null;
  email?: string | null;
  phone?: string | null;
  isDefault?: boolean;
};

export const createCompanyZodschema = z.object({
  name: z.string().min(1),
  addressLine1: z.string().min(1),
  addressLine2: z.string().optional(),
  city: z.string().min(1),
  postalCode: z.string().min(1),
  country: z.string().min(1),
  vatNumber: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  isDefault: z.boolean().optional(),
});

export type CreateCompanyFields = UnifiedFieldSelection<CompanyResourceSchema>[];

type InferCreateCompanyResult<
  Fields extends CreateCompanyFields,
> = InferResult<CompanyResourceSchema, Fields>;

export type CreateCompanyResult<Fields extends CreateCompanyFields> = | { success: true; data: InferCreateCompanyResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCompany<Fields extends CreateCompanyFields>(
  config: {
  input: CreateCompanyInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateCompanyResult<Fields>> {
  const payload = {
    action: "create_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCompanyResult<Fields>;
}


export type ValidateCreateCompanyResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCompany(
  config: {
  input: CreateCompanyInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateCompanyResult> {
  const payload = {
    action: "create_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCompanyResult;
}


export type GetCompanyInput = {
  id?: UUID;
};

export const getCompanyZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetCompanyFields = UnifiedFieldSelection<CompanyResourceSchema>[];

type InferGetCompanyResult<
  Fields extends GetCompanyFields,
> = InferResult<CompanyResourceSchema, Fields> | null;

export type GetCompanyResult<Fields extends GetCompanyFields> = | { success: true; data: InferGetCompanyResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCompany<Fields extends GetCompanyFields>(
  config: {
  input: GetCompanyInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetCompanyResult<Fields>> {
  const payload = {
    action: "get_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCompanyResult<Fields>;
}


export type ValidateGetCompanyResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCompany(
  config: {
  input: GetCompanyInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetCompanyResult> {
  const payload = {
    action: "get_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCompanyResult;
}


export type UpdateCompanyInput = {
  name: string;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber?: string | null;
  email?: string | null;
  phone?: string | null;
  isDefault?: boolean;
};

export const updateCompanyZodschema = z.object({
  name: z.string().min(1),
  addressLine1: z.string().min(1),
  addressLine2: z.string().optional(),
  city: z.string().min(1),
  postalCode: z.string().min(1),
  country: z.string().min(1),
  vatNumber: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  isDefault: z.boolean().optional(),
});

export type UpdateCompanyFields = UnifiedFieldSelection<CompanyResourceSchema>[];

type InferUpdateCompanyResult<
  Fields extends UpdateCompanyFields,
> = InferResult<CompanyResourceSchema, Fields>;

export type UpdateCompanyResult<Fields extends UpdateCompanyFields> = | { success: true; data: InferUpdateCompanyResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateCompany<Fields extends UpdateCompanyFields>(
  config: {
  primaryKey: UUID;
  input: UpdateCompanyInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateCompanyResult<Fields>> {
  const payload = {
    action: "update_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateCompanyResult<Fields>;
}


export type ValidateUpdateCompanyResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateCompany(
  config: {
  primaryKey: string;
  input: UpdateCompanyInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateCompanyResult> {
  const payload = {
    action: "update_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateCompanyResult;
}




export type DeleteCompanyResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteCompany(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteCompanyResult> {
  const payload = {
    action: "delete_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteCompanyResult;
}


export type ValidateDeleteCompanyResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteCompany(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteCompanyResult> {
  const payload = {
    action: "delete_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteCompanyResult;
}



export type ListCompaniesFields = UnifiedFieldSelection<CompanyResourceSchema>[];

type InferListCompaniesResult<
  Fields extends ListCompaniesFields,
> = {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListCompaniesResult<Fields extends ListCompaniesFields> = | { success: true; data: InferListCompaniesResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCompanies<Fields extends ListCompaniesFields>(
  config: {
  fields: Fields;
  filter?: CompanyFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
}
): Promise<ListCompaniesResult<Fields>> {
  const payload = {
    action: "list_companies",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCompaniesResult<Fields>;
}


export type ValidateListCompaniesResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCompanies(
  config: {
  headers?: Record<string, string>;
}
): Promise<ValidateListCompaniesResult> {
  const payload = {
    action: "list_companies",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCompaniesResult;
}



export type GetDefaultCompanyFields = UnifiedFieldSelection<CompanyResourceSchema>[];

type InferGetDefaultCompanyResult<
  Fields extends GetDefaultCompanyFields,
> = Array<InferResult<CompanyResourceSchema, Fields>>;

export type GetDefaultCompanyResult<Fields extends GetDefaultCompanyFields> = | { success: true; data: InferGetDefaultCompanyResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getDefaultCompany<Fields extends GetDefaultCompanyFields>(
  config: {
  fields: Fields;
  filter?: CompanyFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<GetDefaultCompanyResult<Fields>> {
  const payload = {
    action: "get_default_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetDefaultCompanyResult<Fields>;
}


export type ValidateGetDefaultCompanyResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetDefaultCompany(
  config: {
  headers?: Record<string, string>;
}
): Promise<ValidateGetDefaultCompanyResult> {
  const payload = {
    action: "get_default_company",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetDefaultCompanyResult;
}


export type CreateCustomerInput = {
  name: string;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber?: string | null;
  email?: string | null;
  phone?: string | null;
  isActive?: boolean;
};

export const createCustomerZodschema = z.object({
  name: z.string().min(1),
  addressLine1: z.string().min(1),
  addressLine2: z.string().optional(),
  city: z.string().min(1),
  postalCode: z.string().min(1),
  country: z.string().min(1),
  vatNumber: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type CreateCustomerFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferCreateCustomerResult<
  Fields extends CreateCustomerFields,
> = InferResult<CustomerResourceSchema, Fields>;

export type CreateCustomerResult<Fields extends CreateCustomerFields> = | { success: true; data: InferCreateCustomerResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCustomer<Fields extends CreateCustomerFields>(
  config: {
  input: CreateCustomerInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateCustomerResult<Fields>> {
  const payload = {
    action: "create_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCustomerResult<Fields>;
}


export type ValidateCreateCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCustomer(
  config: {
  input: CreateCustomerInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateCustomerResult> {
  const payload = {
    action: "create_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCustomerResult;
}


export type GetCustomerInput = {
  id?: UUID;
};

export const getCustomerZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetCustomerFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferGetCustomerResult<
  Fields extends GetCustomerFields,
> = InferResult<CustomerResourceSchema, Fields> | null;

export type GetCustomerResult<Fields extends GetCustomerFields> = | { success: true; data: InferGetCustomerResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCustomer<Fields extends GetCustomerFields>(
  config: {
  input: GetCustomerInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetCustomerResult<Fields>> {
  const payload = {
    action: "get_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCustomerResult<Fields>;
}


export type ValidateGetCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCustomer(
  config: {
  input: GetCustomerInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetCustomerResult> {
  const payload = {
    action: "get_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCustomerResult;
}


export type UpdateCustomerInput = {
  name: string;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  postalCode: string;
  country: string;
  vatNumber?: string | null;
  email?: string | null;
  phone?: string | null;
  isActive?: boolean;
};

export const updateCustomerZodschema = z.object({
  name: z.string().min(1),
  addressLine1: z.string().min(1),
  addressLine2: z.string().optional(),
  city: z.string().min(1),
  postalCode: z.string().min(1),
  country: z.string().min(1),
  vatNumber: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type UpdateCustomerFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferUpdateCustomerResult<
  Fields extends UpdateCustomerFields,
> = InferResult<CustomerResourceSchema, Fields>;

export type UpdateCustomerResult<Fields extends UpdateCustomerFields> = | { success: true; data: InferUpdateCustomerResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateCustomer<Fields extends UpdateCustomerFields>(
  config: {
  primaryKey: UUID;
  input: UpdateCustomerInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateCustomerResult<Fields>> {
  const payload = {
    action: "update_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateCustomerResult<Fields>;
}


export type ValidateUpdateCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateCustomer(
  config: {
  primaryKey: string;
  input: UpdateCustomerInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateCustomerResult> {
  const payload = {
    action: "update_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateCustomerResult;
}




export type DeleteCustomerResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteCustomer(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteCustomerResult> {
  const payload = {
    action: "delete_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteCustomerResult;
}


export type ValidateDeleteCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteCustomer(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteCustomerResult> {
  const payload = {
    action: "delete_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteCustomerResult;
}



export type ListActiveCustomersFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferListActiveCustomersResult<
  Fields extends ListActiveCustomersFields,
> = Array<InferResult<CustomerResourceSchema, Fields>>;

export type ListActiveCustomersResult<Fields extends ListActiveCustomersFields> = | { success: true; data: InferListActiveCustomersResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listActiveCustomers<Fields extends ListActiveCustomersFields>(
  config: {
  fields: Fields;
  filter?: CustomerFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListActiveCustomersResult<Fields>> {
  const payload = {
    action: "list_active_customers",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListActiveCustomersResult<Fields>;
}


export type ValidateListActiveCustomersResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListActiveCustomers(
  config: {
  headers?: Record<string, string>;
}
): Promise<ValidateListActiveCustomersResult> {
  const payload = {
    action: "list_active_customers",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListActiveCustomersResult;
}



export type DeactivateCustomerFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferDeactivateCustomerResult<
  Fields extends DeactivateCustomerFields,
> = InferResult<CustomerResourceSchema, Fields>;

export type DeactivateCustomerResult<Fields extends DeactivateCustomerFields> = | { success: true; data: InferDeactivateCustomerResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deactivateCustomer<Fields extends DeactivateCustomerFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<DeactivateCustomerResult<Fields>> {
  const payload = {
    action: "deactivate_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeactivateCustomerResult<Fields>;
}


export type ValidateDeactivateCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeactivateCustomer(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeactivateCustomerResult> {
  const payload = {
    action: "deactivate_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeactivateCustomerResult;
}



export type ActivateCustomerFields = UnifiedFieldSelection<CustomerResourceSchema>[];

type InferActivateCustomerResult<
  Fields extends ActivateCustomerFields,
> = InferResult<CustomerResourceSchema, Fields>;

export type ActivateCustomerResult<Fields extends ActivateCustomerFields> = | { success: true; data: InferActivateCustomerResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function activateCustomer<Fields extends ActivateCustomerFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<ActivateCustomerResult<Fields>> {
  const payload = {
    action: "activate_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ActivateCustomerResult<Fields>;
}


export type ValidateActivateCustomerResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateActivateCustomer(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateActivateCustomerResult> {
  const payload = {
    action: "activate_customer",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateActivateCustomerResult;
}


export type CreateInvoiceInput = {
  issueDate: AshDate;
  dueDate: AshDate;
  currency?: string;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2?: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber?: string | null;
  companyEmail?: string | null;
  companyPhone?: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2?: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber?: string | null;
  customerEmail?: string | null;
  customerPhone?: string | null;
  invoiceLines?: Array<Record<string, any>>;
};

export const createInvoiceZodschema = z.object({
  issueDate: z.iso.date(),
  dueDate: z.iso.date(),
  currency: z.string().min(1).optional(),
  companyName: z.string().min(1),
  companyAddressLine1: z.string().min(1),
  companyAddressLine2: z.string().optional(),
  companyCity: z.string().min(1),
  companyPostalCode: z.string().min(1),
  companyCountry: z.string().min(1),
  companyVatNumber: z.string().optional(),
  companyEmail: z.string().optional(),
  companyPhone: z.string().optional(),
  customerName: z.string().min(1),
  customerAddressLine1: z.string().min(1),
  customerAddressLine2: z.string().optional(),
  customerCity: z.string().min(1),
  customerPostalCode: z.string().min(1),
  customerCountry: z.string().min(1),
  customerVatNumber: z.string().optional(),
  customerEmail: z.string().optional(),
  customerPhone: z.string().optional(),
  invoiceLines: z.array(z.record(z.string(), z.any())).optional(),
});

export type CreateInvoiceFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferCreateInvoiceResult<
  Fields extends CreateInvoiceFields,
> = InferResult<InvoiceResourceSchema, Fields>;

export type CreateInvoiceResult<Fields extends CreateInvoiceFields> = | { success: true; data: InferCreateInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createInvoice<Fields extends CreateInvoiceFields>(
  config: {
  input: CreateInvoiceInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateInvoiceResult<Fields>> {
  const payload = {
    action: "create_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateInvoiceResult<Fields>;
}


export type ValidateCreateInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateInvoice(
  config: {
  input: CreateInvoiceInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateInvoiceResult> {
  const payload = {
    action: "create_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateInvoiceResult;
}


export type GetInvoiceInput = {
  id?: UUID;
};

export const getInvoiceZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetInvoiceFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferGetInvoiceResult<
  Fields extends GetInvoiceFields,
> = InferResult<InvoiceResourceSchema, Fields> | null;

export type GetInvoiceResult<Fields extends GetInvoiceFields> = | { success: true; data: InferGetInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getInvoice<Fields extends GetInvoiceFields>(
  config: {
  input: GetInvoiceInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetInvoiceResult<Fields>> {
  const payload = {
    action: "get_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetInvoiceResult<Fields>;
}


export type ValidateGetInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetInvoice(
  config: {
  input: GetInvoiceInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetInvoiceResult> {
  const payload = {
    action: "get_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetInvoiceResult;
}


export type UpdateInvoiceInput = {
  issueDate: AshDate;
  dueDate: AshDate;
  currency?: string;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2?: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber?: string | null;
  companyEmail?: string | null;
  companyPhone?: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2?: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber?: string | null;
  customerEmail?: string | null;
  customerPhone?: string | null;
  invoiceLines?: Array<Record<string, any>>;
};

export const updateInvoiceZodschema = z.object({
  issueDate: z.iso.date(),
  dueDate: z.iso.date(),
  currency: z.string().min(1).optional(),
  companyName: z.string().min(1),
  companyAddressLine1: z.string().min(1),
  companyAddressLine2: z.string().optional(),
  companyCity: z.string().min(1),
  companyPostalCode: z.string().min(1),
  companyCountry: z.string().min(1),
  companyVatNumber: z.string().optional(),
  companyEmail: z.string().optional(),
  companyPhone: z.string().optional(),
  customerName: z.string().min(1),
  customerAddressLine1: z.string().min(1),
  customerAddressLine2: z.string().optional(),
  customerCity: z.string().min(1),
  customerPostalCode: z.string().min(1),
  customerCountry: z.string().min(1),
  customerVatNumber: z.string().optional(),
  customerEmail: z.string().optional(),
  customerPhone: z.string().optional(),
  invoiceLines: z.array(z.record(z.string(), z.any())).optional(),
});

export type UpdateInvoiceFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferUpdateInvoiceResult<
  Fields extends UpdateInvoiceFields,
> = InferResult<InvoiceResourceSchema, Fields>;

export type UpdateInvoiceResult<Fields extends UpdateInvoiceFields> = | { success: true; data: InferUpdateInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateInvoice<Fields extends UpdateInvoiceFields>(
  config: {
  primaryKey: UUID;
  input: UpdateInvoiceInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateInvoiceResult<Fields>> {
  const payload = {
    action: "update_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateInvoiceResult<Fields>;
}


export type ValidateUpdateInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateInvoice(
  config: {
  primaryKey: string;
  input: UpdateInvoiceInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateInvoiceResult> {
  const payload = {
    action: "update_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateInvoiceResult;
}




export type DeleteInvoiceResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteInvoice(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteInvoiceResult> {
  const payload = {
    action: "delete_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteInvoiceResult;
}


export type ValidateDeleteInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteInvoice(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteInvoiceResult> {
  const payload = {
    action: "delete_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteInvoiceResult;
}



export type ListInvoicesFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferListInvoicesResult<
  Fields extends ListInvoicesFields,
> = {
  results: Array<InferResult<InvoiceResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<InvoiceResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListInvoicesResult<Fields extends ListInvoicesFields> = | { success: true; data: InferListInvoicesResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listInvoices<Fields extends ListInvoicesFields>(
  config: {
  fields: Fields;
  filter?: InvoiceFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
}
): Promise<ListInvoicesResult<Fields>> {
  const payload = {
    action: "list_invoices",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListInvoicesResult<Fields>;
}


export type ValidateListInvoicesResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListInvoices(
  config: {
  headers?: Record<string, string>;
}
): Promise<ValidateListInvoicesResult> {
  const payload = {
    action: "list_invoices",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListInvoicesResult;
}


export type ListInvoicesByStateInput = {
  state: string;
};

export const listInvoicesByStateZodschema = z.object({
  state: z.string(),
});

export type ListInvoicesByStateFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferListInvoicesByStateResult<
  Fields extends ListInvoicesByStateFields,
> = Array<InferResult<InvoiceResourceSchema, Fields>>;

export type ListInvoicesByStateResult<Fields extends ListInvoicesByStateFields> = | { success: true; data: InferListInvoicesByStateResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listInvoicesByState<Fields extends ListInvoicesByStateFields>(
  config: {
  input: ListInvoicesByStateInput;
  fields: Fields;
  filter?: InvoiceFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListInvoicesByStateResult<Fields>> {
  const payload = {
    action: "list_invoices_by_state",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListInvoicesByStateResult<Fields>;
}


export type ValidateListInvoicesByStateResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListInvoicesByState(
  config: {
  input: ListInvoicesByStateInput;
  headers?: Record<string, string>;
}
): Promise<ValidateListInvoicesByStateResult> {
  const payload = {
    action: "list_invoices_by_state",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListInvoicesByStateResult;
}



export type FinalizeInvoiceFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferFinalizeInvoiceResult<
  Fields extends FinalizeInvoiceFields,
> = InferResult<InvoiceResourceSchema, Fields>;

export type FinalizeInvoiceResult<Fields extends FinalizeInvoiceFields> = | { success: true; data: InferFinalizeInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function finalizeInvoice<Fields extends FinalizeInvoiceFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<FinalizeInvoiceResult<Fields>> {
  const payload = {
    action: "finalize_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as FinalizeInvoiceResult<Fields>;
}


export type ValidateFinalizeInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateFinalizeInvoice(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateFinalizeInvoiceResult> {
  const payload = {
    action: "finalize_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateFinalizeInvoiceResult;
}



export type CancelInvoiceFields = UnifiedFieldSelection<InvoiceResourceSchema>[];

type InferCancelInvoiceResult<
  Fields extends CancelInvoiceFields,
> = InferResult<InvoiceResourceSchema, Fields>;

export type CancelInvoiceResult<Fields extends CancelInvoiceFields> = | { success: true; data: InferCancelInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function cancelInvoice<Fields extends CancelInvoiceFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CancelInvoiceResult<Fields>> {
  const payload = {
    action: "cancel_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CancelInvoiceResult<Fields>;
}


export type ValidateCancelInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCancelInvoice(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateCancelInvoiceResult> {
  const payload = {
    action: "cancel_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCancelInvoiceResult;
}


export type CreateInvoiceLineInput = {
  invoiceId: UUID;
  lineNumber: number;
  description: string;
  quantity?: Decimal;
  unitPrice: Decimal;
  taxRate?: Decimal;
};

export const createInvoiceLineZodschema = z.object({
  invoiceId: z.uuid(),
  lineNumber: z.number().int(),
  description: z.string().min(1),
  quantity: z.string().optional(),
  unitPrice: z.string(),
  taxRate: z.string().optional(),
});

export type CreateInvoiceLineFields = UnifiedFieldSelection<InvoiceLineResourceSchema>[];

type InferCreateInvoiceLineResult<
  Fields extends CreateInvoiceLineFields,
> = InferResult<InvoiceLineResourceSchema, Fields>;

export type CreateInvoiceLineResult<Fields extends CreateInvoiceLineFields> = | { success: true; data: InferCreateInvoiceLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createInvoiceLine<Fields extends CreateInvoiceLineFields>(
  config: {
  input: CreateInvoiceLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateInvoiceLineResult<Fields>> {
  const payload = {
    action: "create_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateInvoiceLineResult<Fields>;
}


export type ValidateCreateInvoiceLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateInvoiceLine(
  config: {
  input: CreateInvoiceLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateInvoiceLineResult> {
  const payload = {
    action: "create_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateInvoiceLineResult;
}


export type GetInvoiceLineInput = {
  id?: UUID;
};

export const getInvoiceLineZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetInvoiceLineFields = UnifiedFieldSelection<InvoiceLineResourceSchema>[];

type InferGetInvoiceLineResult<
  Fields extends GetInvoiceLineFields,
> = InferResult<InvoiceLineResourceSchema, Fields> | null;

export type GetInvoiceLineResult<Fields extends GetInvoiceLineFields> = | { success: true; data: InferGetInvoiceLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getInvoiceLine<Fields extends GetInvoiceLineFields>(
  config: {
  input: GetInvoiceLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetInvoiceLineResult<Fields>> {
  const payload = {
    action: "get_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetInvoiceLineResult<Fields>;
}


export type ValidateGetInvoiceLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetInvoiceLine(
  config: {
  input: GetInvoiceLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetInvoiceLineResult> {
  const payload = {
    action: "get_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetInvoiceLineResult;
}


export type UpdateInvoiceLineInput = {
  lineNumber: number;
  description: string;
  quantity?: Decimal;
  unitPrice: Decimal;
  taxRate?: Decimal;
};

export const updateInvoiceLineZodschema = z.object({
  lineNumber: z.number().int(),
  description: z.string().min(1),
  quantity: z.string().optional(),
  unitPrice: z.string(),
  taxRate: z.string().optional(),
});

export type UpdateInvoiceLineFields = UnifiedFieldSelection<InvoiceLineResourceSchema>[];

type InferUpdateInvoiceLineResult<
  Fields extends UpdateInvoiceLineFields,
> = InferResult<InvoiceLineResourceSchema, Fields>;

export type UpdateInvoiceLineResult<Fields extends UpdateInvoiceLineFields> = | { success: true; data: InferUpdateInvoiceLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateInvoiceLine<Fields extends UpdateInvoiceLineFields>(
  config: {
  primaryKey: UUID;
  input: UpdateInvoiceLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateInvoiceLineResult<Fields>> {
  const payload = {
    action: "update_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateInvoiceLineResult<Fields>;
}


export type ValidateUpdateInvoiceLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateInvoiceLine(
  config: {
  primaryKey: string;
  input: UpdateInvoiceLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateInvoiceLineResult> {
  const payload = {
    action: "update_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateInvoiceLineResult;
}




export type DeleteInvoiceLineResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteInvoiceLine(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteInvoiceLineResult> {
  const payload = {
    action: "delete_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteInvoiceLineResult;
}


export type ValidateDeleteInvoiceLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteInvoiceLine(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteInvoiceLineResult> {
  const payload = {
    action: "delete_invoice_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteInvoiceLineResult;
}


export type ListInvoiceLinesInput = {
  invoiceId: UUID;
};

export const listInvoiceLinesZodschema = z.object({
  invoiceId: z.uuid(),
});

export type ListInvoiceLinesFields = UnifiedFieldSelection<InvoiceLineResourceSchema>[];

type InferListInvoiceLinesResult<
  Fields extends ListInvoiceLinesFields,
> = Array<InferResult<InvoiceLineResourceSchema, Fields>>;

export type ListInvoiceLinesResult<Fields extends ListInvoiceLinesFields> = | { success: true; data: InferListInvoiceLinesResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listInvoiceLines<Fields extends ListInvoiceLinesFields>(
  config: {
  input: ListInvoiceLinesInput;
  fields: Fields;
  filter?: InvoiceLineFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListInvoiceLinesResult<Fields>> {
  const payload = {
    action: "list_invoice_lines",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListInvoiceLinesResult<Fields>;
}


export type ValidateListInvoiceLinesResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListInvoiceLines(
  config: {
  input: ListInvoiceLinesInput;
  headers?: Record<string, string>;
}
): Promise<ValidateListInvoiceLinesResult> {
  const payload = {
    action: "list_invoice_lines",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListInvoiceLinesResult;
}


export type GetInvoiceLineByNumberInput = {
  invoiceId: UUID;
  lineNumber: number;
};

export const getInvoiceLineByNumberZodschema = z.object({
  invoiceId: z.uuid(),
  lineNumber: z.number().int(),
});

export type GetInvoiceLineByNumberFields = UnifiedFieldSelection<InvoiceLineResourceSchema>[];

type InferGetInvoiceLineByNumberResult<
  Fields extends GetInvoiceLineByNumberFields,
> = Array<InferResult<InvoiceLineResourceSchema, Fields>>;

export type GetInvoiceLineByNumberResult<Fields extends GetInvoiceLineByNumberFields> = | { success: true; data: InferGetInvoiceLineByNumberResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getInvoiceLineByNumber<Fields extends GetInvoiceLineByNumberFields>(
  config: {
  input: GetInvoiceLineByNumberInput;
  fields: Fields;
  filter?: InvoiceLineFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<GetInvoiceLineByNumberResult<Fields>> {
  const payload = {
    action: "get_invoice_line_by_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetInvoiceLineByNumberResult<Fields>;
}


export type ValidateGetInvoiceLineByNumberResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetInvoiceLineByNumber(
  config: {
  input: GetInvoiceLineByNumberInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetInvoiceLineByNumberResult> {
  const payload = {
    action: "get_invoice_line_by_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetInvoiceLineByNumberResult;
}


export type CreateCreditNoteInput = {
  issueDate: AshDate;
  originalInvoiceId?: UUID | null;
  creditReason: string;
  currency?: string;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2?: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber?: string | null;
  companyEmail?: string | null;
  companyPhone?: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2?: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber?: string | null;
  customerEmail?: string | null;
  customerPhone?: string | null;
  creditNoteLines?: Array<Record<string, any>>;
};

export const createCreditNoteZodschema = z.object({
  issueDate: z.iso.date(),
  originalInvoiceId: z.uuid().optional(),
  creditReason: z.string().min(1),
  currency: z.string().min(1).optional(),
  companyName: z.string().min(1),
  companyAddressLine1: z.string().min(1),
  companyAddressLine2: z.string().optional(),
  companyCity: z.string().min(1),
  companyPostalCode: z.string().min(1),
  companyCountry: z.string().min(1),
  companyVatNumber: z.string().optional(),
  companyEmail: z.string().optional(),
  companyPhone: z.string().optional(),
  customerName: z.string().min(1),
  customerAddressLine1: z.string().min(1),
  customerAddressLine2: z.string().optional(),
  customerCity: z.string().min(1),
  customerPostalCode: z.string().min(1),
  customerCountry: z.string().min(1),
  customerVatNumber: z.string().optional(),
  customerEmail: z.string().optional(),
  customerPhone: z.string().optional(),
  creditNoteLines: z.array(z.record(z.string(), z.any())).optional(),
});

export type CreateCreditNoteFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferCreateCreditNoteResult<
  Fields extends CreateCreditNoteFields,
> = InferResult<CreditNoteResourceSchema, Fields>;

export type CreateCreditNoteResult<Fields extends CreateCreditNoteFields> = | { success: true; data: InferCreateCreditNoteResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCreditNote<Fields extends CreateCreditNoteFields>(
  config: {
  input: CreateCreditNoteInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateCreditNoteResult<Fields>> {
  const payload = {
    action: "create_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCreditNoteResult<Fields>;
}


export type ValidateCreateCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCreditNote(
  config: {
  input: CreateCreditNoteInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateCreditNoteResult> {
  const payload = {
    action: "create_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCreditNoteResult;
}


export type CreateCreditNoteFromInvoiceInput = {
  invoiceId: UUID;
  creditReason: string;
};

export const createCreditNoteFromInvoiceZodschema = z.object({
  invoiceId: z.uuid(),
  creditReason: z.string().min(1),
});

export type CreateCreditNoteFromInvoiceFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferCreateCreditNoteFromInvoiceResult<
  Fields extends CreateCreditNoteFromInvoiceFields,
> = InferResult<CreditNoteResourceSchema, Fields>;

export type CreateCreditNoteFromInvoiceResult<Fields extends CreateCreditNoteFromInvoiceFields> = | { success: true; data: InferCreateCreditNoteFromInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCreditNoteFromInvoice<Fields extends CreateCreditNoteFromInvoiceFields>(
  config: {
  input: CreateCreditNoteFromInvoiceInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateCreditNoteFromInvoiceResult<Fields>> {
  const payload = {
    action: "create_credit_note_from_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCreditNoteFromInvoiceResult<Fields>;
}


export type ValidateCreateCreditNoteFromInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCreditNoteFromInvoice(
  config: {
  input: CreateCreditNoteFromInvoiceInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateCreditNoteFromInvoiceResult> {
  const payload = {
    action: "create_credit_note_from_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCreditNoteFromInvoiceResult;
}


export type GetCreditNoteInput = {
  id?: UUID;
};

export const getCreditNoteZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetCreditNoteFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferGetCreditNoteResult<
  Fields extends GetCreditNoteFields,
> = InferResult<CreditNoteResourceSchema, Fields> | null;

export type GetCreditNoteResult<Fields extends GetCreditNoteFields> = | { success: true; data: InferGetCreditNoteResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCreditNote<Fields extends GetCreditNoteFields>(
  config: {
  input: GetCreditNoteInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetCreditNoteResult<Fields>> {
  const payload = {
    action: "get_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCreditNoteResult<Fields>;
}


export type ValidateGetCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCreditNote(
  config: {
  input: GetCreditNoteInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetCreditNoteResult> {
  const payload = {
    action: "get_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCreditNoteResult;
}


export type UpdateCreditNoteInput = {
  issueDate: AshDate;
  originalInvoiceId?: UUID | null;
  creditReason: string;
  currency?: string;
  companyName: string;
  companyAddressLine1: string;
  companyAddressLine2?: string | null;
  companyCity: string;
  companyPostalCode: string;
  companyCountry: string;
  companyVatNumber?: string | null;
  companyEmail?: string | null;
  companyPhone?: string | null;
  customerName: string;
  customerAddressLine1: string;
  customerAddressLine2?: string | null;
  customerCity: string;
  customerPostalCode: string;
  customerCountry: string;
  customerVatNumber?: string | null;
  customerEmail?: string | null;
  customerPhone?: string | null;
  creditNoteLines?: Array<Record<string, any>>;
};

export const updateCreditNoteZodschema = z.object({
  issueDate: z.iso.date(),
  originalInvoiceId: z.uuid().optional(),
  creditReason: z.string().min(1),
  currency: z.string().min(1).optional(),
  companyName: z.string().min(1),
  companyAddressLine1: z.string().min(1),
  companyAddressLine2: z.string().optional(),
  companyCity: z.string().min(1),
  companyPostalCode: z.string().min(1),
  companyCountry: z.string().min(1),
  companyVatNumber: z.string().optional(),
  companyEmail: z.string().optional(),
  companyPhone: z.string().optional(),
  customerName: z.string().min(1),
  customerAddressLine1: z.string().min(1),
  customerAddressLine2: z.string().optional(),
  customerCity: z.string().min(1),
  customerPostalCode: z.string().min(1),
  customerCountry: z.string().min(1),
  customerVatNumber: z.string().optional(),
  customerEmail: z.string().optional(),
  customerPhone: z.string().optional(),
  creditNoteLines: z.array(z.record(z.string(), z.any())).optional(),
});

export type UpdateCreditNoteFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferUpdateCreditNoteResult<
  Fields extends UpdateCreditNoteFields,
> = InferResult<CreditNoteResourceSchema, Fields>;

export type UpdateCreditNoteResult<Fields extends UpdateCreditNoteFields> = | { success: true; data: InferUpdateCreditNoteResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateCreditNote<Fields extends UpdateCreditNoteFields>(
  config: {
  primaryKey: UUID;
  input: UpdateCreditNoteInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateCreditNoteResult<Fields>> {
  const payload = {
    action: "update_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateCreditNoteResult<Fields>;
}


export type ValidateUpdateCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateCreditNote(
  config: {
  primaryKey: string;
  input: UpdateCreditNoteInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateCreditNoteResult> {
  const payload = {
    action: "update_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateCreditNoteResult;
}




export type DeleteCreditNoteResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteCreditNote(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteCreditNoteResult> {
  const payload = {
    action: "delete_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteCreditNoteResult;
}


export type ValidateDeleteCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteCreditNote(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteCreditNoteResult> {
  const payload = {
    action: "delete_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteCreditNoteResult;
}



export type ListCreditNotesFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferListCreditNotesResult<
  Fields extends ListCreditNotesFields,
> = Array<InferResult<CreditNoteResourceSchema, Fields>>;

export type ListCreditNotesResult<Fields extends ListCreditNotesFields> = | { success: true; data: InferListCreditNotesResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCreditNotes<Fields extends ListCreditNotesFields>(
  config: {
  fields: Fields;
  filter?: CreditNoteFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListCreditNotesResult<Fields>> {
  const payload = {
    action: "list_credit_notes",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCreditNotesResult<Fields>;
}


export type ValidateListCreditNotesResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCreditNotes(
  config: {
  headers?: Record<string, string>;
}
): Promise<ValidateListCreditNotesResult> {
  const payload = {
    action: "list_credit_notes",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCreditNotesResult;
}


export type ListCreditNotesByStateInput = {
  state: string;
};

export const listCreditNotesByStateZodschema = z.object({
  state: z.string(),
});

export type ListCreditNotesByStateFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferListCreditNotesByStateResult<
  Fields extends ListCreditNotesByStateFields,
> = Array<InferResult<CreditNoteResourceSchema, Fields>>;

export type ListCreditNotesByStateResult<Fields extends ListCreditNotesByStateFields> = | { success: true; data: InferListCreditNotesByStateResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCreditNotesByState<Fields extends ListCreditNotesByStateFields>(
  config: {
  input: ListCreditNotesByStateInput;
  fields: Fields;
  filter?: CreditNoteFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListCreditNotesByStateResult<Fields>> {
  const payload = {
    action: "list_credit_notes_by_state",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCreditNotesByStateResult<Fields>;
}


export type ValidateListCreditNotesByStateResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCreditNotesByState(
  config: {
  input: ListCreditNotesByStateInput;
  headers?: Record<string, string>;
}
): Promise<ValidateListCreditNotesByStateResult> {
  const payload = {
    action: "list_credit_notes_by_state",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCreditNotesByStateResult;
}


export type ListCreditNotesForInvoiceInput = {
  invoiceId: UUID;
};

export const listCreditNotesForInvoiceZodschema = z.object({
  invoiceId: z.uuid(),
});

export type ListCreditNotesForInvoiceFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferListCreditNotesForInvoiceResult<
  Fields extends ListCreditNotesForInvoiceFields,
> = Array<InferResult<CreditNoteResourceSchema, Fields>>;

export type ListCreditNotesForInvoiceResult<Fields extends ListCreditNotesForInvoiceFields> = | { success: true; data: InferListCreditNotesForInvoiceResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCreditNotesForInvoice<Fields extends ListCreditNotesForInvoiceFields>(
  config: {
  input: ListCreditNotesForInvoiceInput;
  fields: Fields;
  filter?: CreditNoteFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListCreditNotesForInvoiceResult<Fields>> {
  const payload = {
    action: "list_credit_notes_for_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCreditNotesForInvoiceResult<Fields>;
}


export type ValidateListCreditNotesForInvoiceResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCreditNotesForInvoice(
  config: {
  input: ListCreditNotesForInvoiceInput;
  headers?: Record<string, string>;
}
): Promise<ValidateListCreditNotesForInvoiceResult> {
  const payload = {
    action: "list_credit_notes_for_invoice",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCreditNotesForInvoiceResult;
}



export type FinalizeCreditNoteFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferFinalizeCreditNoteResult<
  Fields extends FinalizeCreditNoteFields,
> = InferResult<CreditNoteResourceSchema, Fields>;

export type FinalizeCreditNoteResult<Fields extends FinalizeCreditNoteFields> = | { success: true; data: InferFinalizeCreditNoteResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function finalizeCreditNote<Fields extends FinalizeCreditNoteFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<FinalizeCreditNoteResult<Fields>> {
  const payload = {
    action: "finalize_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as FinalizeCreditNoteResult<Fields>;
}


export type ValidateFinalizeCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateFinalizeCreditNote(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateFinalizeCreditNoteResult> {
  const payload = {
    action: "finalize_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateFinalizeCreditNoteResult;
}



export type CancelCreditNoteFields = UnifiedFieldSelection<CreditNoteResourceSchema>[];

type InferCancelCreditNoteResult<
  Fields extends CancelCreditNoteFields,
> = InferResult<CreditNoteResourceSchema, Fields>;

export type CancelCreditNoteResult<Fields extends CancelCreditNoteFields> = | { success: true; data: InferCancelCreditNoteResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function cancelCreditNote<Fields extends CancelCreditNoteFields>(
  config: {
  primaryKey: UUID;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CancelCreditNoteResult<Fields>> {
  const payload = {
    action: "cancel_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CancelCreditNoteResult<Fields>;
}


export type ValidateCancelCreditNoteResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCancelCreditNote(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateCancelCreditNoteResult> {
  const payload = {
    action: "cancel_credit_note",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCancelCreditNoteResult;
}


export type CreateCreditNoteLineInput = {
  creditNoteId: UUID;
  lineNumber: number;
  description: string;
  quantity?: Decimal;
  unitPrice: Decimal;
  taxRate?: Decimal;
};

export const createCreditNoteLineZodschema = z.object({
  creditNoteId: z.uuid(),
  lineNumber: z.number().int(),
  description: z.string().min(1),
  quantity: z.string().optional(),
  unitPrice: z.string(),
  taxRate: z.string().optional(),
});

export type CreateCreditNoteLineFields = UnifiedFieldSelection<CreditNoteLineResourceSchema>[];

type InferCreateCreditNoteLineResult<
  Fields extends CreateCreditNoteLineFields,
> = InferResult<CreditNoteLineResourceSchema, Fields>;

export type CreateCreditNoteLineResult<Fields extends CreateCreditNoteLineFields> = | { success: true; data: InferCreateCreditNoteLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCreditNoteLine<Fields extends CreateCreditNoteLineFields>(
  config: {
  input: CreateCreditNoteLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<CreateCreditNoteLineResult<Fields>> {
  const payload = {
    action: "create_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCreditNoteLineResult<Fields>;
}


export type ValidateCreateCreditNoteLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCreditNoteLine(
  config: {
  input: CreateCreditNoteLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateCreateCreditNoteLineResult> {
  const payload = {
    action: "create_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCreditNoteLineResult;
}


export type GetCreditNoteLineInput = {
  id?: UUID;
};

export const getCreditNoteLineZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetCreditNoteLineFields = UnifiedFieldSelection<CreditNoteLineResourceSchema>[];

type InferGetCreditNoteLineResult<
  Fields extends GetCreditNoteLineFields,
> = InferResult<CreditNoteLineResourceSchema, Fields> | null;

export type GetCreditNoteLineResult<Fields extends GetCreditNoteLineFields> = | { success: true; data: InferGetCreditNoteLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCreditNoteLine<Fields extends GetCreditNoteLineFields>(
  config: {
  input: GetCreditNoteLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetCreditNoteLineResult<Fields>> {
  const payload = {
    action: "get_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCreditNoteLineResult<Fields>;
}


export type ValidateGetCreditNoteLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCreditNoteLine(
  config: {
  input: GetCreditNoteLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetCreditNoteLineResult> {
  const payload = {
    action: "get_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCreditNoteLineResult;
}


export type UpdateCreditNoteLineInput = {
  lineNumber: number;
  description: string;
  quantity?: Decimal;
  unitPrice: Decimal;
  taxRate?: Decimal;
};

export const updateCreditNoteLineZodschema = z.object({
  lineNumber: z.number().int(),
  description: z.string().min(1),
  quantity: z.string().optional(),
  unitPrice: z.string(),
  taxRate: z.string().optional(),
});

export type UpdateCreditNoteLineFields = UnifiedFieldSelection<CreditNoteLineResourceSchema>[];

type InferUpdateCreditNoteLineResult<
  Fields extends UpdateCreditNoteLineFields,
> = InferResult<CreditNoteLineResourceSchema, Fields>;

export type UpdateCreditNoteLineResult<Fields extends UpdateCreditNoteLineFields> = | { success: true; data: InferUpdateCreditNoteLineResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateCreditNoteLine<Fields extends UpdateCreditNoteLineFields>(
  config: {
  primaryKey: UUID;
  input: UpdateCreditNoteLineInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<UpdateCreditNoteLineResult<Fields>> {
  const payload = {
    action: "update_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateCreditNoteLineResult<Fields>;
}


export type ValidateUpdateCreditNoteLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateCreditNoteLine(
  config: {
  primaryKey: string;
  input: UpdateCreditNoteLineInput;
  headers?: Record<string, string>;
}
): Promise<ValidateUpdateCreditNoteLineResult> {
  const payload = {
    action: "update_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateCreditNoteLineResult;
}




export type DeleteCreditNoteLineResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteCreditNoteLine(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
}
): Promise<DeleteCreditNoteLineResult> {
  const payload = {
    action: "delete_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteCreditNoteLineResult;
}


export type ValidateDeleteCreditNoteLineResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteCreditNoteLine(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
}
): Promise<ValidateDeleteCreditNoteLineResult> {
  const payload = {
    action: "delete_credit_note_line",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteCreditNoteLineResult;
}


export type ListCreditNoteLinesInput = {
  creditNoteId: UUID;
};

export const listCreditNoteLinesZodschema = z.object({
  creditNoteId: z.uuid(),
});

export type ListCreditNoteLinesFields = UnifiedFieldSelection<CreditNoteLineResourceSchema>[];

type InferListCreditNoteLinesResult<
  Fields extends ListCreditNoteLinesFields,
> = Array<InferResult<CreditNoteLineResourceSchema, Fields>>;

export type ListCreditNoteLinesResult<Fields extends ListCreditNoteLinesFields> = | { success: true; data: InferListCreditNoteLinesResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCreditNoteLines<Fields extends ListCreditNoteLinesFields>(
  config: {
  input: ListCreditNoteLinesInput;
  fields: Fields;
  filter?: CreditNoteLineFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<ListCreditNoteLinesResult<Fields>> {
  const payload = {
    action: "list_credit_note_lines",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCreditNoteLinesResult<Fields>;
}


export type ValidateListCreditNoteLinesResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCreditNoteLines(
  config: {
  input: ListCreditNoteLinesInput;
  headers?: Record<string, string>;
}
): Promise<ValidateListCreditNoteLinesResult> {
  const payload = {
    action: "list_credit_note_lines",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCreditNoteLinesResult;
}


export type GetCreditNoteLineByNumberInput = {
  creditNoteId: UUID;
  lineNumber: number;
};

export const getCreditNoteLineByNumberZodschema = z.object({
  creditNoteId: z.uuid(),
  lineNumber: z.number().int(),
});

export type GetCreditNoteLineByNumberFields = UnifiedFieldSelection<CreditNoteLineResourceSchema>[];

type InferGetCreditNoteLineByNumberResult<
  Fields extends GetCreditNoteLineByNumberFields,
> = Array<InferResult<CreditNoteLineResourceSchema, Fields>>;

export type GetCreditNoteLineByNumberResult<Fields extends GetCreditNoteLineByNumberFields> = | { success: true; data: InferGetCreditNoteLineByNumberResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCreditNoteLineByNumber<Fields extends GetCreditNoteLineByNumberFields>(
  config: {
  input: GetCreditNoteLineByNumberInput;
  fields: Fields;
  filter?: CreditNoteLineFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<GetCreditNoteLineByNumberResult<Fields>> {
  const payload = {
    action: "get_credit_note_line_by_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCreditNoteLineByNumberResult<Fields>;
}


export type ValidateGetCreditNoteLineByNumberResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCreditNoteLineByNumber(
  config: {
  input: GetCreditNoteLineByNumberInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetCreditNoteLineByNumberResult> {
  const payload = {
    action: "get_credit_note_line_by_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCreditNoteLineByNumberResult;
}


export type GetSequenceNumberInput = {
  id?: UUID;
};

export const getSequenceNumberZodschema = z.object({
  id: z.uuid().optional(),
});

export type GetSequenceNumberFields = UnifiedFieldSelection<SequenceNumberResourceSchema>[];

type InferGetSequenceNumberResult<
  Fields extends GetSequenceNumberFields,
> = InferResult<SequenceNumberResourceSchema, Fields> | null;

export type GetSequenceNumberResult<Fields extends GetSequenceNumberFields> = | { success: true; data: InferGetSequenceNumberResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getSequenceNumber<Fields extends GetSequenceNumberFields>(
  config: {
  input: GetSequenceNumberInput;
  fields: Fields;
  headers?: Record<string, string>;
}
): Promise<GetSequenceNumberResult<Fields>> {
  const payload = {
    action: "get_sequence_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetSequenceNumberResult<Fields>;
}


export type ValidateGetSequenceNumberResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetSequenceNumber(
  config: {
  input: GetSequenceNumberInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetSequenceNumberResult> {
  const payload = {
    action: "get_sequence_number",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetSequenceNumberResult;
}


export type GetSequenceForUserAndTypeInput = {
  userId: UUID;
  documentType: string;
};

export const getSequenceForUserAndTypeZodschema = z.object({
  userId: z.uuid(),
  documentType: z.string(),
});

export type GetSequenceForUserAndTypeFields = UnifiedFieldSelection<SequenceNumberResourceSchema>[];

type InferGetSequenceForUserAndTypeResult<
  Fields extends GetSequenceForUserAndTypeFields,
> = Array<InferResult<SequenceNumberResourceSchema, Fields>>;

export type GetSequenceForUserAndTypeResult<Fields extends GetSequenceForUserAndTypeFields> = | { success: true; data: InferGetSequenceForUserAndTypeResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getSequenceForUserAndType<Fields extends GetSequenceForUserAndTypeFields>(
  config: {
  input: GetSequenceForUserAndTypeInput;
  fields: Fields;
  filter?: SequenceNumberFilterInput;
  sort?: string;
  headers?: Record<string, string>;
}
): Promise<GetSequenceForUserAndTypeResult<Fields>> {
  const payload = {
    action: "get_sequence_for_user_and_type",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/run", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetSequenceForUserAndTypeResult<Fields>;
}


export type ValidateGetSequenceForUserAndTypeResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetSequenceForUserAndType(
  config: {
  input: GetSequenceForUserAndTypeInput;
  headers?: Record<string, string>;
}
): Promise<ValidateGetSequenceForUserAndTypeResult> {
  const payload = {
    action: "get_sequence_for_user_and_type",
    ...config
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const response = await fetch("/rpc/validate", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetSequenceForUserAndTypeResult;
}


